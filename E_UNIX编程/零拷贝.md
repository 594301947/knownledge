

### 1. 几个重要的概念

#### 1.1. 用户空间/内核空间

- 操作系统的核心是内核（内核的权限很大），它独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的所有权限
- 为了保护用户进程不能直接操作内核，保证内核安全，操作系统将进程虚拟空间划分为2部分：内核空间、用户空间

#### 1.2. 常规IO拷贝流程

常规的read/write要经过：4次用户空间/内核空间来回切换，4次拷贝，详细见下图。

分析：可以看到，CPU的两次拷贝是多余的（即第2、3次拷贝）

---

### 2. 零拷贝

零拷贝就是为了避免CPU将数据从一块存储拷贝到另一块存储。

- 减少CPU拷贝次数
- 减少用户空间/内核空间的上下文切换次数

零拷贝技术要点：

- 数据拷贝尽量让DMA来做
- 避免数据在用户空间/内核空间的来回拷贝

DMA：指外部设备不通过CPU而直接与系统内存交换数据的接口技术

![常规IO流程](https://github.com/gEricy/knownledge/blob/master/E_UNIX%E7%BC%96%E7%A8%8B/image/%E5%B8%B8%E8%A7%84IO%E6%B5%81%E7%A8%8B.png)

#### sendfile实现零拷贝的原理

sendfile系统调用：在两个fd之间传递数据（完全是在内核中操作），避免了数据在内核缓冲区/用户缓冲区之间的来回拷贝，操作效率很高。

- 细节（3次拷贝）
  - 利用DMA引擎，将磁盘中的数据拷贝到内核缓冲区
  - 之后，再将内核缓冲区中的数据拷贝到与socket相关的内核缓冲区中
  - 利用DMA引擎，将数据从内核socket缓冲区拷贝到网络协议栈中

可以看到，这里没有用户态/内核态之间的切换，也没有内核缓冲区/用户缓冲区之间的数据拷贝，所有的数据拷贝都是在内核中完成的。

![sendfile零拷贝](https://github.com/gEricy/knownledge/blob/master/E_UNIX%E7%BC%96%E7%A8%8B/image/%E5%B8%B8%E8%A7%84IO%E6%B5%81%E7%A8%8B.png)

#### 带有DMA收集拷贝功能的sendfile

上面介绍的sendfile技术在进行数据传输时，通过引入硬件上的帮助，仍然可以进一步优化（第二次拷贝可以被优化掉：从文件中读取的数据，不需要拷贝到内核socket buffer中，而是直接拷贝到网络协议栈中）

- 硬件应该需要以下功能
  - 能够收集拷贝信息
- 主要过程：硬盘—>内核缓冲区—>网络协议栈
  - sendfile系统调用利用DMA引擎将文件内容先拷贝到内核缓冲区
  - 之后，将带有文件位置和长度信息的缓冲区描述符添加到socket缓冲区中（此过程不需要将数据从操作系统内核缓冲区拷贝到socket缓冲区中）。DAM引擎会将数据直接从内核缓冲区拷贝到网络协议栈中

![](https://github.com/gEricy/knownledge/blob/master/E_UNIX%E7%BC%96%E7%A8%8B/image/%E5%B8%A6MDA%E7%9A%84sendfile.png)