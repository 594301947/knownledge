## brk/mmap

操作系统只提供了2套用于内存分配的系统调用：brk(+/-)，mmap/unmap

注意：brk/mmap都是申请的虚拟地址，不是直接分配内存空间；当进程使用内存是才发生缺页中断，才真正的执行内存分配。

1. 每次申请内存，都要调用brk/mmap，那么每次都要产生系统调用开销（即cpu从用户态切换到内核态的上下文切换，这里要保存用户态数据，等会还要切换回用户态），这是非常影响性能的
2. 容易产生内存碎片

> brk(+/-): <128K  堆, 移动指针（brk释放内存时，要等到高地址内存释放后，低地址内存才能释放，容易产生内存碎片）
>
> mmap/umap: >128K 堆和栈中间的文件映射区域（匿名映射，不是映射文件，而是从文件映射区申请一块空闲内存）

---

## [malloc(glibc)](https://zhuanlan.zhihu.com/p/57863097)

​        malloc底层实现原理是内存池：采用类似于STL的内存分配器，先申请一块大内存，然后将内存分成不同级别的内存块，用bins表示。

#### 1. [bins]

> **small_bins**: 同一个bins中chunks大小相等，bins之间的chunk相差8byte
>
> **large_bins**: 每个bin包含了一个给定范围的chunk，bins中的每个chunk大小相差64byte
>
> **fast_bins**: 程序在运行时经常需要频繁申请和释放一些较小的内存。当分配器合并、回收了相邻的几个小的chunk后（当不大于max_fast默认值为64Byte），将会直接释放到fast_bins中。
>
> **unsorted_bins**：当fast_bins中空闲的chunk合并后，且大小大于max_fast，会将该内存挂在unsorted_bins中
>
> > 引出fast_bins与unsorted_bins的好处：减少查询small_bins/large_bins，加快内存分配速度

---

#### 2. [top_chunk, mmap]

2. 当chunk足够大，fast bin和bins都不能满足要求，甚至top chunk都不能满足时，malloc会从mmap来直接使用内存映射来将页映射到进程空间，这样的chunk释放时，直接解除映射，归还给操作系统。（极限大的时候）
3. Last remainder是另外一种特殊的chunk，就像top chunk和mmaped chunk一样，不会在任何bins中找到这种chunk。当需要分配一个small chunk，但在small bins中找不到合适的chunk，如果last remainder chunk的大小大于所需要的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。（这个应该是fast bins中也找不到合适的时候，用于极限小的）




## [slab机制、伙伴算法](https://www.cnblogs.com/wangzahngjun/p/4977425.html)

【伙伴算法】--解决外部碎片（页框浪费）

[【slab机制】](https://www.cnblogs.com/libertylife/p/9577249.html)--分配机制--解决内部碎片（页内浪费）


---

## map的clear/erase会释放内存么？

场景：不断的insert元素，内存会持续增加，为什么调用erase/clear，并不会释放内存，为什么？

结论：STL底层的分配器allocator在搞鬼，就相当于，篮子上的苹果被摘除了，但是篮子还在。


