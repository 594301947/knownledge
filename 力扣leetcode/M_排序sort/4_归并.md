- ### 归并排序

```c
二路归并：mid=(l+r)/2
辅助数组：B

void merge(int A[], int B[], int l, int mid, int r){
	int k = l;
	int i = l, j = mid + 1;
	
	// 1. 合并A[l,mid] A[mid+1,r]，临时保存到辅助数组B上
	while (i <= mid && j <= r){
		B[k++] = A[i] < A[j] ? A[i++] : A[j++];
	}
	while (i <= mid)
		B[k++] = A[i++];
	while (j <= r)
		B[k++] = A[j++];
	
	// 2. 将辅助数组B中的元素，再拷贝回原数组A上
	for (int i = l; i <= r; i++)
		A[i] = B[i];
}
void merge_sort(int A[],int B[], int l, int r){
	// 程序执行的条件: 至少两个数 l != r
	if (l < r) { 
		int mid = (l + r) / 2;
		merge_sort(A, B, l, mid);
		merge_sort(A, B, mid + 1, r);
		merge(A, B, l, mid, r);
	}
}

void printA(int A[], int n){
	for (int i = 0; i < n; i++)
		cout << A[i] << "   ";
}

int main(){
	int A[] = { 1,5,6,8,1,2,3,6,5,55};
	int len = sizeof(A) / sizeof(A[0]);
	
	int *B = new int[len];    // 辅助数组 B
	merge_sort(A, B, 0, len-1);
	
	printA(A, len);
}
```



---



- ### 小和

```c
int ret = 0;
void merge(int A[], int B[], int l, int mid, int r){
	int k = l;
	int i = l, j = mid + 1;
    
    // 1. 合并A[l,mid] A[mid+1,r]，临时保存到辅助数组B上
	while (i <= mid && j <= r){
		if (A[i] < A[j]){  //小和
			ret += (r - j + 1) * A[i];
		}
		B[k++] = A[i] < A[j] ? A[i++] : A[j++];
	}
	while (i <= mid)
		B[k++] = A[i++];
	while (j <= r)
		B[k++] = A[j++];
    
    // 2. 将辅助数组B中的元素，再拷贝回原数组A上
	for (int i = l; i <= r; i++)
		A[i] = B[i];
}

void merge_sort(int A[],int B[], int l, int r){
	if (l < r){
		int mid = (l + r) / 2;
		merge_sort(A, B, l, mid);
		merge_sort(A, B, mid + 1, r);
		merge(A, B, l, mid, r);
	}
}

void printA(int A[], int n){
	for (int i = 0; i < n; i++)
		cout << A[i] << "   ";
	cout << endl;
}

int main(){
	int A[] = { 1, 3, 5, 2, 4, 6 };
	int len = sizeof(A) / sizeof(A[0]);
	int *B = new int[len + 1];
	merge_sort(A, B,0,len-1);
	cout << ret << endl; //小和  27
	printA(A, len);
}
```

- ### 逆序对

```c
void merge(int A[], int B[], int l, int mid, int r){
	int k = l;
	int i = l, j = mid + 1;
    
    // 1. 合并A[l,mid] A[mid+1,r]，临时保存到辅助数组B上
	while (i <= mid && j <= r){ 
		if (A[i] > A[j]){ //找到逆序点j, { vec[i], vec[m+1,j] }
			for (int pos = mid + 1; pos <= j; pos++)
				ret.emplace_back(A[i], A[pos]);
		}
		B[k++] = A[i] < A[j] ? A[i++] : A[j++];
	}
	while (i <= mid)
		B[k++] = A[i++];
	while (j <= r)
		B[k++] = A[j++];
    
    // 2. 将辅助数组B中的元素，再拷贝回原数组A上
	for (int i = l; i <= r; i++)
		A[i] = B[i];
}
void merge_sort(int A[],int B[], int l, int r){
	if (l < r){
		int mid = (l + r) / 2;
		merge_sort(A, B, l, mid);
		merge_sort(A, B, mid + 1, r);
		merge(A, B, l, mid, r);
	}
}
int main(){
	int A[] = { 7, 5, 6, 4 };
	int len = sizeof(A) / sizeof(A[0]);
	int *B = new int[len + 1];
	merge_sort(A, B,0,len-1);
	cout << "逆序对" << endl;
	for (auto node : ret)
		cout << "  " << node.first << ", " << node.second << endl;

	system("pause");
}

```

