:slightly_smiling_face: 二叉搜索树（BST）

- 中序遍历，递增

---

#### [98. 判断二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```c++
class Solution {
public:
    long pre = LONG_MIN;  // 关键点, 用long类型
    bool isValidBST(TreeNode* root) {
        if(!root)
            return true;
        
        bool L = isValidBST(root->left);  // 左子树
        if (!L)
            return false;

        if (pre >= root->val)             // 根
            return false;
        pre = root->val;
        
        return isValidBST(root->right);   // 右子树
    }
};
```

#### 110. 判断AVL树

- BST
- 高度差不超过2

```c++
class Solution {
public:
    // 判断是否为
    long pre = LONG_MIN;  // 关键点, 用long类型
    bool isValidBST(TreeNode* root) {
        if(!root)
            return true;
        
        bool L = isValidBST(root->left);  // 左子树
        if (!L)
            return false;

        if (pre >= root->val)             // 根
            return false;
        pre = root->val;
        
        return isValidBST(root->right);   // 右子树
    }

    // 二叉树高度
    int DFS(TreeNode* T){
        if(!T)
            return 0;
        return 1 + max(DFS(T->left), DFS(T->right));
    }
    bool isBalanced(TreeNode* root) {
        if(!root)
            return true;
        int lh = DFS(root->left);
        int rh = DFS(root->right);
        if(abs((rh - lh)) > 1)
            return false;
        return isBalanced(root->left) && isBalanced(root->right);
    }
    
    bool isAVL(TreeNode* root) {
        //    平衡(高度差不超过2) && 二叉搜索树
    	return isBalanced(root) && isValidBST(root);
    }
};
```



#### [面试题 17.12. BiNode](https://leetcode-cn.com/problems/binode-lcci/)

- 二叉搜索树转换为单向链表，保持链表单调性

```c++
二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。
返回转换后的单向链表的头节点。
```

```c++
// 中序遍历
class Solution {
public:
    TreeNode* head = NULL;
    TreeNode* pre = NULL;

    void dfs(TreeNode* T){
        if(!T)
            return;
        
        dfs(T->left); // 左

        // 根
        if (pre == NULL) {   // 第一个节点
            head = T;
        }
        else {
            pre->right = T;  // 连成链表
            T->left = NULL;
        }
        pre = T;
        
        dfs(T->right); // 右
    }

    TreeNode* convertBiNode(TreeNode* root) {
        dfs(root);
        return head;
    }
};
```



#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

```c++
class Solution {
public:
    int ret = INT_MAX;
    int pre = INT_MIN;
    void dfs(TreeNode* T){
        if(!T)
            return;

        dfs(T->left);    // 左子树

        // 根
        if (pre == INT_MIN){  // 第一个节点
            pre = T->val;
        }
        else {
            ret = min(ret, abs(T->val - pre));
            pre = T->val;
        }

        dfs(T->right);   // 右子树
    }
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        return ret;
    }
};
```



#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```c++
class Solution {
public:
    int ret;
    void dfs(TreeNode* T, int& k){
        if(!T)
            return;
        dfs(T->left, k);   // 左子树

        // 注: 统一处理(不能将--k放在递归左子树之前!)
        if (--k == 0) {    // 根
            ret = T->val;
            return;
        }      
        dfs(T->right, k);  // 右子树
    }
    int kthSmallest(TreeNode* root, int k) {
        dfs(root, k);
        return ret;        
    }
};
```

#### [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/) （字节）

```c++

```

