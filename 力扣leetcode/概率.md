:small_airplane: 随机数生成器

---



#### [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。

不要使用系统的 Math.random() 方法。

```python
'''
rand7()                --> [1,2,...,7]
rand7()-1              --> [0,1,...,6]
(rand7()-1)*7          --> [0,7,...,42]
(rand7()-1)*7+rand7()  --> [1,2,...,49]  等概率生成[1,49]中的随机数

[1,49]不是10的倍数，要“拒绝采样”，即:[1,40]

[1,40],再%10           --> [0,1,...,9]   等概率生成[0,9]中的随机数
再+1                   --> [1,2,...,10]  等概率生成[1,10]中的随机数

'''
class Solution(object):
    def rand10(self):
        while True:
            rand49 = (rand7()-1)*7+rand7()
            if rand49 <= 40:  # 拒绝采样，丢弃[1,40]之外的数据
                return rand49%10+1
        return -1
```

#### 等概率产生0和1

- 有一个随机数发生器，能以概率p生成0，以概率1-p生成1，问如何做一个随机数发生器 
  使得生成0和1的概率相等。 

解法：

① 由于生成01和10的概率均为p(1-p)，故预先任意指定01为0（或1），10为1（或0）即可。即可等概率的产生0和1。

② 可以用原发生器周期性地产生2个数，直到生成01或者10。 

```c++
int Rand()
{
	int i1 = rand();
	int i2 = rand();
	if(i1==0 && i2==1)        // 如果是(0,1) --> 1
		return 1;
	else if(i1==1 && i2==0)   // 如果是(1,0) --> 0
		return 0;
	else					  // 如果是其他，则递归调用Rand(), 直到生成(0,1)或(1,0)
		return Rand();
	return -1;
}
```

#### 上题延申

用上面那个生成0和1的概率相等的随机数发生器，怎样做一个随机数发生器使得它生成的数在1...N之间均匀分布。

答案：第二题采用位运算，因为i个二进制位随机的选择0或1，可以随机的构成0~2^i的数，而这些数构成了所有的组合数。因此是等概率出现的。

比如：2位二进制位，这两位可以随机为0或1而互不影响，随机的构成了00 01 10 11，它们代表了四个数，且这四个数是等概率的。

```c++
int newRand()
{
	int result = 0;
	for(int i = 0 ; i < k ; ++i)
	{
		if(Rand() == 1)
			result |= (1<<i);
	}
	if(result > n)  // 大于n，就重新再计算，直到结果在n内
		return newRand();
	return result;
}
```

