- **条件变量**

  > pthread_cond_wait 原理
  >
  > > UNLOCK
  > >
  > > 等待条件被唤醒
  > >
  > > LOCK

```c
#include <stdlib.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

// 必须用2个条件变量 + 1把锁
pthread_mutex_t g_mutex;
pthread_cond_t  g_cond1, g_cond2;

int g_num = 1;

#define MAX_NUM 4

void* thread1(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&g_mutex);
        {
            if (g_num > MAX_NUM) {
                pthread_cond_signal(&g_cond2);      // 唤醒线程2
                pthread_mutex_unlock(&g_mutex);     // 要解锁
                goto end;
            }
            printf("tid(%lu): %d \n", pthread_self(), g_num);
            g_num++;
            
            pthread_cond_signal(&g_cond2);          // 唤醒线程2
            pthread_cond_wait(&g_cond1, &g_mutex);  // 线程1等待
        }
        pthread_mutex_unlock(&g_mutex);

        sleep(1);
    }
end:
    printf("tid(%lu): exit\n", pthread_self());
    return NULL;
}

void* thread2(void* arg)
{
    while(1)
    {
        // 【注】 为了简单，此处暂时用sleep来控制线程打印顺序，在工程中应该用条件变量控制
        //这个sleep(1)加在前面是因为开启线程时有可能是线程2先打印，
        //导致变成thread2输出奇数，threa1输出偶数。为了避免这种情况，可以在延迟下线程2的打印。
        sleep(1);

        pthread_mutex_lock(&g_mutex); 
        {   
            if (g_num > MAX_NUM) {
                pthread_cond_signal(&g_cond1);      // 唤醒线程1
                pthread_mutex_unlock(&g_mutex);     // 要解锁
                goto end;
            }
   
            printf("tid(%lu): %d \n", pthread_self(), g_num);
            g_num++;
            
            pthread_cond_signal(&g_cond1);          // 唤醒线程1
            pthread_cond_wait(&g_cond2, &g_mutex);  // 线程2等待
        }
        pthread_mutex_unlock(&g_mutex);
    }
end:
    printf("tid(%lu): exit\n", pthread_self());
    return NULL;
}

int main()
{
    pthread_t tid1, tid2;

    // 初始化
    pthread_mutex_init(&g_mutex, NULL);
    pthread_cond_init(&g_cond1, NULL);
    pthread_cond_init(&g_cond2, NULL);

    pthread_create(&tid1, NULL, thread1, NULL);
    pthread_create(&tid2, NULL, thread2, NULL);
    
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    // 销毁
    pthread_mutex_destroy(&g_mutex);
    pthread_cond_destroy(&g_cond1);
    pthread_cond_destroy(&g_cond2);

    return 0;
}
```

