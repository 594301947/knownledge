
:kissing_smiling_eyes: 递归回溯

- 最核心的点
  - 如何确定`可选集合`？

```python
def backtrace(nums, land):
	if 满足条件:
		ans.append(land)
		return
	for elem in 可选集合:
		land.append(elem)     # 加入可选数elem
		backtrace(nums, land) # 回溯
		land.pop()            # 移除之前加入的可选数elem
```

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

**一个元素只能被使用一次**

```python
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```python
class Solution(object):
    def combine(self, n, k):
        nums = [i+1 for i in range(n)]  # 将n转换成list
        ans = []
        land = []
        size = len(nums)
        def backtrace(nums, land, start):
            if len(land) == k:
                ans.append(land[:])
                return
            for i in range(start, size):  # 可选集合 ∈ [start, size)
                land.append(nums[i])
                backtrace(nums, land, i+1)
                land.pop()
        backtrace(nums, land, 0)
        return ans
```

#### [ 组合总和](https://leetcode-cn.com/problems/combination-sum/)

39. 给定一个`无重复`元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

`candidates 中的数字可以无限制重复被选取。`



```python
class Solution(object):
    def combinationSum(self, candidates, target):
        ret = []
        land = []
        def backtrace(candidates, land, target, start):
            if target == 0:
                ret.append(land[:])
                return
            for i in range(start, len(candidates)):
                if target - candidates[i] < 0:
                    continue
                land.append(candidates[i])
                backtrace(candidates, land, target - candidates[i], i)  # 注意：此处不是i+1，而是i，包含i (不允许后退)
                land.pop()
        backtrace(candidates, land, target, 0)
        return ret
```

40. 给定一个 `可能存在重复数` 的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

`candidates 中的每个数字在每个组合中只能使用一次`

要求：

- 所有数字（包括目标数）都是正整数。
- 解集不能包含重复的组合。 

```python
class Solution(object):
    def combinationSum2(self, candidates, target):
        ans = []
        land = []
        size = len(candidates)
        candidates.sort()
        def backtrace(candidates, land, target, start):
            if target == 0:
                ans.append(land[:])
                return
            for i in range(start, size):
                if i > start and candidates[i] == candidates[i-1]:
                    continue
                if target - candidates[i] < 0:
                    continue
                land.append(candidates[i])
                backtrace(candidates, land, target-candidates[i], i+1) # 不能重复使用
                land.pop()
        backtrace(candidates, land, target, 0)
        return ans
```



#### [子集](https://leetcode-cn.com/problems/subsets/)

**题78：无重复元素**

```python
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```python
class Solution(object):
    def subsets(self, nums):
        ans = []
        land = []
        size = len(nums)
        def backtrace(nums, land, start):
            ans.append(land[:])
            for i in range(start, size):
                land.append(nums[i])
                backtrace(nums, land, i+1)
                land.pop()
        backtrace(nums, land, 0)
        return ans
```

**题90：可能存在重复元素（需要剪枝）**

```python
class Solution(object):
    def subsetsWithDup(self, nums):
        ans = []
        land = []
        size = len(nums)
        nums.sort()
        def backtrace(nums, land, start):
            ans.append(land[:])
            for i in range(start, size):
                if i > start and nums[i] == nums[i-1]:  # 剪枝
                    continue
                land.append(nums[i])
                backtrace(nums, land, i+1)
                land.pop()
        backtrace(nums, land, 0)
        return ans
```

