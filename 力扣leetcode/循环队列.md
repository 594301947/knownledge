- 思想
  - 多开一个元素，用于判断empty和full
  - 尾指针w_idx：指向尾元素的下一个位置（即：插入位置）
  - 头指针r_idx：指向头元素

> 初始化：多开辟一个位置，头尾指针都为0
>
> arr = malloc(sizeof(int) * (size) + 1)
>
> capacity = size+1
>
> r_idx=w_idx=0
>
> ----
>
> 空： 头尾指针相等，即：r_idx == w_idx
>
> 满： 尾指针的下一个位置 == 头指针，即：(w_idx+1)%capacity == r_idx
>
> ---
>
> 插入元素：① 插入 arr[w_idx] = value ② 更新w_idx，即：w_idx = (w_idx+1)%capacity
>
> 删除元素：更新r_idx，即：r_idx = (r_idx+1)%capacity
>
> ---
>
> 获取头元素：arr[r_idx]
>
> 获取尾元素：尾指针的前一个位置就是尾元素w_idx-1+capacity)%capacity，即：arr[(w_idx-1+capacity)%capacity]

```c++
class MyCircularQueue {
private:
    int* arr;
    int  capacity;
    int  w_idx;
    int  r_idx;
public:
    /** Initialize your data structure here. Set the size of the queue to be k. */
    MyCircularQueue(int k) {
        this->arr = (int*)malloc(sizeof(int) * (k + 1));
        this->capacity = k + 1;
        this->w_idx = this->r_idx = 0;
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    bool enQueue(int value) {
        if (isFull())
            return false;

        // 插入元素
        this->arr[this->w_idx] = value;
        // 更新w_idx
        this->w_idx = (this->w_idx + 1) % this->capacity;
        return true;
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    bool deQueue() {
        if (isEmpty())
            return false;
        
        this->r_idx = (this->r_idx + 1) % this->capacity;
        return true;
    }
    
    /** Get the front item from the queue. */
    int Front() {
        if (isEmpty())
            return -1;
        return this->arr[this->r_idx];        
    }
    
    /** Get the last item from the queue. */
    int Rear() {
        if (isEmpty())
            return -1;
        return this->arr[(this->w_idx - 1 + this->capacity) % this->capacity];
    }
    
    /** Checks whether the circular queue is empty or not. */
    bool isEmpty() {
        return this->r_idx == this->w_idx;
    }
    
    /** Checks whether the circular queue is full or not. */
    bool isFull() {
        return (this->w_idx + 1) % this->capacity == this->r_idx;
    }
};
```

