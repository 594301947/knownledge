
**python的list模拟栈**

- 获取栈顶：stack[-1]
- 弹出栈顶：stack.pop(-1)

**单调栈**

- 栈中元素的大小是保持递增or递减的

---

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```python
请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，
	给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
	你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```

```python
class Solution(object):
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        ret = [0] * len(T)  # 保存结果[0, 0, 0, ... ...]
        stack = []  # 存放下标
        for i in range(len(T)):
            while stack != [] and T[stack[-1]] < T[i]:  # 栈顶温度 < 当前温度
                ret[stack[-1]] = i - stack[-1]  # 更新对应位置的结果值
                stack.pop()
            stack.append(i)
        return ret
```



#### [402. 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

给定一个以字符串表示的非负整数 *num*，移除这个数中的 *k* 位数字，使得剩下的数字最小。

```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219	。
```

```python
class Solution(object):
    def removeKdigits(self, num, k):
        """
        :type num: str
        :type k: int
        :rtype: str
        """
        stack = []
        for e in num:
            while stack != [] and stack[-1] > e and k:  # 单调栈: while循环保证栈内元素始终是单调的
                stack.pop()
                k -= 1
            stack.append(e)  # 始终都将当前元素加入栈
        ret = stack[:-k] if(k > 0) else stack
        return "".join(ret).lstrip('0') or '0'
```



#### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

给定两个 `没有重复元素` 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

```
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
```



```python
class Solution(object):
    def nextGreaterElement(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        stack = []
        hash = {}
        for e in nums2:
            while stack != [] and stack[-1] < e:  # 单调栈
                hash[stack[-1]] = e  # 将<元素,第一个比元素大的值>保存到哈希表
                stack.pop()
            stack.append(e)
        ret = []
        for e in nums1: # 遍历每个元素，从哈希表中找其对应的第一个较大值
            if e in hash.keys():
                ret.append(hash[e])
            else:
                ret.append(-1)
        return ret
```



#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

```shell
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```



```python
class Solution(object):
    def nextGreaterElements(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        db_nums = nums * 2  # 将两个数组拼接
        size = len(nums)    # 原数组长度
        ret = [-1] * size   # 初始化结果[-1, -1, -1, ... ...]
        stack = []  # 栈 (栈中存放着下标)
        for i in range(size * 2):
            while stack != [] and db_nums[stack[-1]] < db_nums[i]:
                ret[stack[-1]] = db_nums[i]  # 保存结果
                stack.pop()
            if i < size: # 虚拟节点不入栈
                stack.append(i)
        return ret
```

