写在最前，前段时间有新闻：美国一程序员枪杀同事，原因竟然是同时写代码太恶心。额… …，所以，我也应该时刻提醒自己不能被枪杀。:smile:本文只写了自己容易犯的小错误，并不会一一罗列所有场景。

----

#### 1. 代码规范

##### 命名规范

- 函数采用驼峰式/下划线式都可以，但是要统一命名格式。如: sendMessage，send_message
- 去掉所有的非前置元音（前置元音保留）。如：computer->cmptr
- 变量名：全局变量g_xxx， 全局静态变量s_xxx，普通变量（不用加前缀）

##### 空格保证代码不紧凑，美观

- 双目运算符两边加空格
- for加空格：for(int i = 0; i < MAX_NUM; i++)

##### 注释

```c
/* *
 * @brief: 给事件注册回调函数
 * @param  [out]  ev  事件
 * @param  [in]   cbk 回调函数
 * @param  [in]   arg 回调函数参数
 * */
int32_t
event_assign(struct event *ev,void (*callback)(evutil_socket_t, short, void *), void *arg)
```

##### 魔数magic

不要滥用魔数

---

#### 2. 安全性

SQL注入：不允许将外部传入的参数，直接拼到SQL语句上，执行之

命令注入：不允许调用system/popen

目录穿越：攻击者能访问任意目录，应该验证字符串中是否包含“截断字符串”、./、../

缓冲区溢出：数值int溢出、strncpy拷贝数据溢出、局部变量栈溢出（8M）

----

sharemem_taboo - 共享内存中不要存放指针： 在共享内存中不要存放指针，而应该以偏移（相对共享内存首地址的偏移）来代替。

原因：共享内存在不同进程中加载的地址可能不一样，在共享内存中存放的指针可能在某些进程中失效。 如果该指针指向非共享内存，则其它进程中根本访问不到。如果该指针指向共享内存中某个地址，则在其它进程中可能会发生错位或无法访问。 虽然可以强行指定将动态连接库加载到相同的地址，但这样有很多限制，可能不一定成功。



MTU - 发送数据包不得超过MTU： 通过网络发送的数据包长度不得超过路径MTU大小。  路径MTU指的是数据包所经过的所有链路MTU的最小值。 对于IP包来说，以太网的MTU是1500字节，Internet(X.25)一般是576字节。 对于UDP和TCP来说，最大载荷长度还需要减去IP头（最小20字节，有时还带有选项头）和UDP（8字节）/TCP头（最小20字节，有时还带有选项头）长度。 所以，UDP的有效载荷长度应限制在1460字节以内（因为IP包可能还有选项头）。  如果是应用层通过tcp socket发包，系统自动将数据切分成合适大小，不会造成分片，故无需考虑此问题。 如果是在内核发包或使用raw socket，则需自行保证。 UDP无此机制，故应用层需自行保证数据内容长度不超过最大载荷长度。

数据超过MTU大小时需要进行分片，有些设备会直接丢弃分片，导致收不到数据。

