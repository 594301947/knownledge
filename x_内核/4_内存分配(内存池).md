

**内部碎片**: 是指被内核分配出去但是不能被利用的内存

**外部碎片**: 是指由于频繁地申请和释放页框而导致的某些小的连续页框，无法分配给需要大的连续页框的进程而导致的内存碎片

---



## brk/mmap

操作系统只提供了2套用于内存分配的系统调用：brk(+/-)，mmap/unmap

注意：brk/mmap都是申请的虚拟地址，不是直接分配内存空间；当进程使用内存是才发生缺页中断，才真正的执行内存分配。

1. 每次申请内存，都要调用brk/mmap，那么每次都要产生系统调用开销（即cpu从用户态切换到内核态的上下文切换，这里要保存用户态数据，等会还要切换回用户态），这是非常影响性能的
2. 容易产生内存碎片

> brk(+/-): <128K  堆, 移动指针（brk释放内存时，要等到高地址内存释放后，低地址内存才能释放，容易产生内存碎片）
>
> mmap/umap: >128K 堆和栈中间的文件映射区域（匿名映射，不是映射文件，而是从文件映射区申请一块空闲内存）

---

## [malloc(glibc)](https://zhuanlan.zhihu.com/p/57863097)

​        malloc底层实现原理是内存池：采用类似于STL的内存分配器，先申请一块大内存，然后将内存分成不同级别的内存块，用bins表示。

#### 1. [bins]

> **small_bins**: 同一个bins中chunks大小相等，bins之间的chunk相差8byte
>
> **large_bins**: 每个bin包含了一个给定范围的chunk，bins中的每个chunk大小相差64byte
>
> **fast_bins**: 程序在运行时经常需要频繁申请和释放一些较小的内存。当分配器合并、回收了相邻的几个小的chunk后（当不大于max_fast默认值为64Byte），将会直接释放到fast_bins中。
>
> **unsorted_bins**：当fast_bins中空闲的chunk合并后，且大小大于max_fast，会将该内存挂在unsorted_bins中
>
> > 引出fast_bins与unsorted_bins的好处：减少查询small_bins/large_bins，加快内存分配速度

---

#### 2. [top_chunk, mmap]

2. 当chunk足够大，fast bin和bins都不能满足要求，甚至top chunk都不能满足时，malloc会从mmap来直接使用内存映射来将页映射到进程空间，这样的chunk释放时，直接解除映射，归还给操作系统。（极限大的时候）
3. Last remainder是另外一种特殊的chunk，就像top chunk和mmaped chunk一样，不会在任何bins中找到这种chunk。当需要分配一个small chunk，但在small bins中找不到合适的chunk，如果last remainder chunk的大小大于所需要的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。（这个应该是fast bins中也找不到合适的时候，用于极限小的）

---

## map的clear/erase会释放内存么？

场景：不断的insert元素，内存会持续增加，为什么调用erase/clear，并不会释放内存，为什么？

结论：STL底层的分配器allocator在搞鬼，就相当于，篮子上的苹果被摘除了，但是篮子还在。



---

### Slab机制：内存碎片 (小于一个page的内存)

**目的**：解决内部碎片



### 伙伴算法：外部碎片 (“大页”内存的分配)

**核心**：伙伴算法是按2的幂次方大小进行分配内存块

**目的**：它要解决的问题是频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页面，由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框可能无法满足请求

**① 内存分配**

> 2^0~2^10 (4K~4M) --> 链表 ==> 类似于malloc/STL分配器
>
> 伙伴算法是用于分配“页面”
> 算法会先从free_area[2]中查看nr_free是否为空，如果有空闲块，则从中分配；如果没有空闲块，就从它的上一级free_area[3]（每块32K）中分配出16K，并将多余的内存（16K）加入到free_area[2]中去。如果free_area[3]也没有空闲，则从更上一级申请空间，依次递推，直到free_area[max_order]，如果顶级都没有空间，那么就报告分配失败。

**② 内存回收**

> 当释放一个内存块时，先在其对于的free_area链表中查找是否有伙伴存在，如果没有伙伴块，直接将释放的块插入链表头。如果有或板块的存在，则将其从链表摘下，合并成一个大块，然后继续查找合并后的块在更大一级链表中是否有伙伴的存在，直至不能合并或者已经合并至最大块2^10为止。

**优点**

>1.较好的解决外部碎片问题
>
>2.当需要分配若干个内存页面时，用于DMA的内存页面必须连续，伙伴算法很好的满足了这个要求
>
>3.只要请求的块不超过512个页面(2K)，内核就尽量分配连续的页面。

**缺点**

> 1.合并的要求太过严格，只能是满足伙伴关系的块才能合并
>
> 2.碎片问题：一个连续的内存中仅仅一个页面被占用，导致整块内存区都不具备合并的条件
>
> 3.浪费问题：伙伴算法只能分配2的幂次方内存区，当需要8K（2页）时，好说，当需要9K时，那就需要分配16K（4页）的内存空间，但是实际只用到9K空间，多余的7K空间就被浪费掉。
>
> 4.算法的效率问题： 伙伴算法涉及了比较多的计算还有链表和位图的操作，开销还是比较大的，如果每次2^n大小的伙伴块就会合并到2^(n+1)的链表队列中，那么2^n大小链表中的块就会因为合并操作而减少，但系统随后立即有可能又有对该大小块的需求，为此必须再从2^(n+1)大小的链表中拆分，这样的合并又立即拆分的过程是无效率的