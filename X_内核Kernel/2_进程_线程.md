### 进程管理

1. task_struct

   > fork，子进程**全部**继承父进程的信息
   >
   > - fork()
   >
   >   - do_fork ==> _do_fork ==> copy_process ==> 
   >
   >     > copy_files  文件描述符
   >     >
   >     > copy_fs
   >     >
   >     > copy_sighand
   >     >
   >     > copy_signal
   >     >
   >     > copy_mm   内存管理mm_struct
   >     >
   >     > copy_namespace  命名空间（隔离）
   >     >
   >     > copy_io
   >     >
   >     > copy_thread_tls

线程和进程有什么区别？

其实在内核中，**线程就是进程**，即内核线程kernel_thread，它也是一个

```c
pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
{
    return _do_fork(
    		flags|CLONE_VM|CLONE_UNTRACED, 
    		(unsigned long)fn,
            (unsigned long)arg, 
            NULL, NULL, 0);
}
```

- 调度器

  - CFS 完全公平调度器
  - 优先级


------

## 多进程/多线程: 文件?

文件描述符表、文件表项、V-inode表

- 多进程/多线程（都调用open同一个文件）

  > 调用open，使得它们的文件描述符表不同
  >
  > 文件描述符表指向自己的文件表项（具有自己的偏移，相互不干扰）
  >
  > 每个打开文件表项，指向自己的V-inode表

- 父子进程（父进程先调用open，然后fork创建子进程）

  说明：该情况相当于调用了dup

  > 父子进程共用同一个文件表项（共用同一个文件偏移）
  >
  > 父子进程改变偏移，都会干扰对方


---

## 真正`删除文件`的条件

【备注】字节面试题

一个程序，向一个文件中不断的写入数据

1. 删除文件，能删除么？

   答：可以删除，实际上只是删除了文件的属性。

2. 程序会受到一个影响么？

   答：不会

3. 数据写到哪里去了？

   答：数据还是写到原来的位置（inode对应很多个block块）

4. 当kill杀死进程后，文件是否会被真正的删除？

   答：会

总结

> 1-文件真正被删除的条件：没有进程打开它 && 文件的硬链接数==0
>
> 2-OS将硬盘分为两个区：数据区（存放文件数据）+inode区（属性, blocks指针, 等）
>
> 3-一个文件由目录项、inode、数据块组成
>
> > - 目录项：包括文件名和inode节点号
> > - Inode：又称文件索引节点，包含文件的基础信息以及数据块的指针。
> > - 数据块：包含文件的具体内容

---



## 多线程/多进程: 信号处理函数signal

<u>**问题1（多线程）**</u>：一个进程有多个线程，每个线程都注册了某个信号的处理函数，当信号到来时，多线程会怎么处理？

结论：只有一个线程会处理该信号，其他线程不会。一般，谁最后调用signal注册了信号处理函数，谁就会一直处理该信号

> 在多线程环境下，一般会让其他子线程不处理信号，专门用一个线程来处理信号，把异步变成同步处理。

---

<u>**问题2（父子进程）**</u>：子进程会继承父进程的信号处理函数么？

结论：

1. 子进程**会继承**父进程的信号处理函数（当一个进程调用fork时，因为子进程在开始时复制父进程的存储映像，信号捕捉函数的地址在子进程中是有意义的，所以子进程继承父进程的信号处理函数）
2. 特殊的是**exec**，因为exec运行新的程序后会覆盖从父进程继承来的存储映像，那么信号捕捉函数在新程序中已无意义，所以exec会将原先设置为要捕捉的信号都更改为默认动作



