# 前言

写在最前，本文主要以知识框架为主，根据自己对知识掌握的情况，进行知识点的梳理（有的知识点实际上上篇幅很大，但是由于自己已经理解，就没有详细叙述）。

# Redis缓存

#  1. 底层数据结构

## 1.1. 压缩列表ziplist

- 使用场景：含有少数的键，且键是“短整型”、“短字符串”
- 优点：节省内存，实现简单，是连续内存块的顺序存储（有点像变长数组，它通过长度划分每个节点）
- 每个 压缩列表节点构成：前一个节点的长度pre_len 当前节点的长度、类型 当前节点的数据内容
- 连锁更新：当插入和删除元素时，可能会导致连锁更新。 ① （全small）原ziplist节点都是长度小于256：当在idx插入大于256的节点时，idx+1后面的节点e1的成员pre_len无法保存前一个节点的长度，因此，要重分配内存。这样e1内存就扩增了，因为是顺序存储，所以e2、e3后面的元素都要向后移动（更新） ② （big1、small、big2）：当删除small时，将会引起big2后面的节点连锁更新
- 使用场景：列表键、哈希键

## 1.2. 跳跃表

- 结构：是一个多层次的链表，每层节点的next跨度大小都不同，从上到下依次减小
- 时间复杂度：最好O（lgN），最差O（N） 性能可以和AVL树媲美，且实现简单
- 使用场景：zset有序集合键

## 1.3. 哈希表

- rehash（重新散列）：哈希键数量增多/减少，会造成rehash，保证哈希表负载因子维持在一个合理的范围。 分配新的哈希内存空间hash[1] 将原哈希hash[0]，通过rehash（重新计算哈希值），散列/迁移到新哈希hash[1]中 rehash过程不是一次执行的，而是分批次、渐进式执行的。

#  2. Redis五种数据结构

- 字符串键string | 字符串类型的value最大能容纳512M 
- 列表键         | ziplist、linklist               
- 哈希键         | ziplist、hash-table            
- 集合           | intset、hash-table
- 有序集合键     | ziplist、跳跃表                 
- 位图键         | bitmap                          

#  

#  4. 删除机制

- 惰性删除： 只有访问时，采取查看该元素是否过期，过期才真正的删除。 
  - 优点：不需要频繁的删除，消耗CPU资源少 
  - 缺点：占用内存

- 定时删除：开启定时器，定时器到时间时，删除过期数据 
  - 优点：不占用内存
  - 缺点：消耗CPU资源少多

# 5. 持久化RDB/AOF

面试问法：Redis持久化机制介绍，各自优缺点。

## 5.1. RDB

在指定时间间隔内，将内存中的数据和操作，通过【快照】的方式保存到RDB文件，可以配置在N秒内进行一次快照。

- 触发条件

  - 手动触发：save命令和bgsave命令都可以生成RDB文件 save会阻塞Redis服务器进程，直到RDB文件创建完毕为止 bgsave会创建一个子进程，更新RDB文件，父进程可以继续处理请求 

  - 自动触发：redis.conf配置文件save m n，表示当m秒内发生n次变化时，触发bgsave

- 优点：加载数据快，直接读取RDB文件内容加载到内存

- 缺点：① 不安全，会丢失时间间隔内的数据 ② 每次保存RDB文件时，都需要fork一个子进程来持久化，性能开销较大 ③ 加载RDB文件期间，会一直处于阻塞状态，直到载入工作完成位置

## 5.2. AOF

将每次更新写操作，都写到AOF文件，重启时，只需要从头到尾执行一次AOF中的指令，可以恢复数据

- 优点：比较安全，可以配置一次更新写，就写AOF文件
- 缺点：一直更新写操作，会使AOF文件激增，极端场景下，会对硬盘空间造成压力 Redis重启时，需要重新执行一个很大的AOF，时间太长
- rewrite：将对同一个key的操作，合并成一个语句，写入AOF文件

5.3. 恢复顺序

当有AOF时，将会先执行AOF，再执行RDB

# 6. 高可用

## 6.1. 简介

- 高可用：当一台服务器宕机停止服务后，对业务及用户毫无影响

- 主从方式：正常情况下，主机提供服务，并将数据同步到备份机器，当主机宕机后，备机立即开始服务 。一主多从方式，主从之间数据同步。master宕机后，通过选举投票方式选择出新的master，继续提供服务。

- 主从方式主要实现读写分离，提高并发性，通过协调器将请求分发到主从节点上。  主从切换技术：当master服务器宕机后，slave切换为master

##  6.2. 哨兵

- 原理：哨兵将会监控集群中所有的节点；一般为了防止单哨兵节点故障，将配置多个哨兵协同合作。

- 切换过程

  - 主观下线：哨兵A检测到主节点下线后，将不会立即切换主节点，而是认为它客观下线 

  - 询问：哨兵A会询问监听该主节点的其他哨兵，收集汇总信息，当有足够多的主观下限信息时，判断是否为客观下线 

  - 选取新领头哨兵：当有一个哨兵判断为客观下限后，将会选举出领头哨兵，由它进行切换主节点操作

- 缺点

  - 运维复杂；哨兵选举期间，不能对外提供服务（因此如果Master宕机后，不支持并发）

##  6.3. 集群

一个集群通常有多个服务器节点组成。 最开始时，各个服务器节点是相互独立的；之后，将各个节点连接起来

### 6.3.1. 槽指派

- 整个数据库，被划分为N个槽，每个槽记录了一个元组（键值对）
- 当所有的槽都被分配/指派给节点处理后，Redis服务器才会进入上线状态，此时才可以接收和处理客户端发来的数据请求

将槽分配到某个节点的算法一般采用（一致性哈希算法），它对添加/删除节点更友好

### 6.3.2. 在集群中执行命令

- 当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽。
- 如果键所在的槽正好就指派给当前节点，那么当前节点直接执行该命令
- 如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令

### 6.3.3. 重新分片

定义：将任意数量已经指派给某个节点的槽，改为指派给另一个节点，并且相关槽所属的键值对也会从源节点移动到目标节点。

- 重新分片可以在线进行，即：在重新分片过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求

### 6.3.4. 复制

上面已经知道，集群中某个节点维护了某个区域的槽，为了防止该节点挂掉，一般对该节点进行复制

从节点会复制主节点的槽，当某个主节点故障了，因为从节点已经复制了它的槽，所以该从节点将会升级为主节点，继续服务。

### 6.3.5. 故障检测
- 故障检测：每个节点会定时向集群中其他节点发送ping，检测对方是否在线; 
- 集群中各个节点会互相发送消息交换集群中各个节点的状态信息;
- 当某个主节点x疑似下线的数过半时，将会被标记为已下线，之后，会广播给集群中所有节点，告诉它们节点x已经下线

### 6.3.6. 故障转移/raft选主算法

会从下线的主节点的从节点中选取一个，让它成为新的主节点

新节点将会广播一条pong消息，通知其他节点自己已经变成了主节点

新主节点将接管原来已经下线的主节点，继续提供服务

# 7. Redis扩展特性

## 7.1. 发布订阅模式

- 客户端订阅服务端的频道

- 当服务端向该频道中发送消息时，频道中所有的客户端都会收到该消息，执行相应的动作 

## 7.2. 事务

### 7.2.1. SQL/Redis事务对比

SQL和Redis的事务有本质的区别

- SQL事务原理
  - innodb引擎支持的事务，采用Redo log + Undo log来实现
- Redis事务原理
  - 使用乐观锁，只负责监听key有没有被改动。即： 采用watch监听某个key；在执行命令时，检查该被监视的key是否已经被修改；如果该key时被改动，那么事务将会被打断

与SQL事务最大的区别，Redis不支持事务回滚，即使事务在执行过程中出错，也不会回滚，将会一直执行下去，直到事务结束。 因为，开发者认为，事务执行失败，很少会在实际生产环境中出现。

## 7.3. 索引

 Redis没有实现索引，如果需要索引，需要用户自己设置并实现之 



#  8. Redis面试题汇总



## 8.3. Redis是单线程还是多线程? 为什么采用单线程，效率却如此之高?

Redis是单线程还是多线程要从两个方面谈起 

① 服务器接收客户端发来的请求命令是单线程的，它采用了IO多路复用，与libevent事件驱动库一样，它是一种反应堆模式Reactor，服务器单线程同时监听多个事件的到来，当事件到来后，会将就绪事件挂到激活队列中

② 对于每一个就绪队列中任务的处理是多线程的，这也是Reactor模式高性能的体现，Reactor会事先建立一个线程池，线程池中的线程是消费者，当有任务到来时，线程将会获取任务执行它

## 8.4. 为什么redis不能代替SQL进行数据存储

MYSQL是关系型数据库，大部分数据是存储在磁盘上的，以二维表格存储；Redis是非关系型数据库，存放在内存中，以KV存储，一般，当并发量大时，且读很多时，采用Redis降低读压力，Redis一般存放热点数据


# 10. Redis使用场景

## 10.1. String字符串对象

场景：统计网页/贴吧/文章阅读/浏览次数

```python
Incr article:readcnt:1001  # 对文章1001的读次数+1
```



## 10.2. Hash之淘宝商城购物车

## 10.3. List之微博公众号消息流

订阅了某个公众号，当该公众号发文章后，会推送给你！ 特点：消息的发送是有一个时间线的 

```python
LPAUSH msg:{小明微信号ID} 10018    # 发消息
LPAUSH msg:{小明微信号ID} 10011    # 发消息  
LRANGE msg:{小明微信号ID} 0 -1     # 查看最新的消息流列表
```



## 10.5.Bit位之日活量

场景：统计2020/10/03，登录用户数。现在系统有千万级活跃用户，如何实现日活统计，为了增强用户粘性，要上线一个连续打卡发放积分的功能，怎么实现连续打卡用户统计？

```python
将20201003Login作为key，offset作为每个用户，value 0/1表示都否登录，即：

Data    1  0  0  0  1  1  0 
Offset  0  1  2  3  4  5  ... ... 

Setbit 20201003Login 0 1 
Setbit 20201003Login 4 5 

bitcount 20201003Login 0 -1  # 统计日活

将20201003Login, 20201004Login,..., 20201007Login相与，之后再统计1的总个数 # 统计连续几日登录量
```



## 10.6. Set之微信抽奖小程序、微博点赞列表、微博关注模型	

无序不重复，放相同的元素，将会被去重（每个人点击多次抽奖，将会被去重，只视为一次抽奖）

场景1：微信抽奖小程序 

```python
SADD activity:10086 {用户ID}   # 用户点击抽奖按钮后，将加入set
SMEMBERS activity:10086       # 查看参与抽奖的所有用户
SRANDMEMBER activity:10086 2 SPOP activity:10086 2  # 随机抽取count名中奖者
```

场景2：微博点赞

```python
SADD like:{消息ID} {用户ID}      # 点赞
SREM like:{消息ID} {用户ID}      # 取消点赞
SISMEMBER like:{消息ID} {用户ID} # 检查用户是否点过赞
SMEMBERS like:{消息ID} {用户ID}  # 获取点赞的用户列表
SCARD like:{消息ID}             # 获取点赞用户总数
```

场景3：微博关注模型

James --\> {A,B,C} Kobe--\>{A,C,D,R} 

James、Kobe是两个集合Set 

```python
SINTER James Kobe      # 取出James和Kobe共同关注的人（交集） 
SISMEMBER James Jordan # 判断James集合中是否有Jordan 
SDIFF James Kobe       # James可能认识的人
```

场景4：Set实现电商商品类型的筛选 

```python
SADD brand:huawei P30 
SADD brand:xiaomi 6X 
SADD os:android P30 6X
SADD cpu:brand:intel P30 6X 
SADD ram:8G P30 6X
SINTER os:android cpu:brand:intel ram:8G  # -->{P30, 6X}
```



## 10.7. ZSet有序集合之微博热点排行榜

```python
ZINCRBY hotNews:20190722 1   # 点击新闻 
ZREVRANGE hotNews:20190722 0 10 WITH SCORES  # 展示当日排行前十
```



# 11. Redis面试总结

​            在网上无意间，看到一个很好的贴子，里面介绍了较多面试题，也梳理了我们对问题的误区： 

- [整理了2019年40道Redis高频面试题，答案详细解析](https://www.bilibili.com/read/cv4042105/)

- [redis原理总结(很全面)](https://blog.csdn.net/wuyangyang555/article/details/82152005)
- [Redis双写一致性、并发竞争、线程模型](https://www.imooc.com/article/297496)
