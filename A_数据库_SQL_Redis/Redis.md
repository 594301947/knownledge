# 前言

写在最前，本文主要以知识框架为主，根据自己对知识掌握的情况，进行知识点的梳理（有的知识点实际上上篇幅很大，但是由于自己已经理解，就没有详细叙述）。

- 为什么redis不能代替SQL进行数据存储

  MYSQL是关系型数据库，大部分数据是存储在磁盘上的，以二维表格存储；Redis是非关系型数据库，存放在内存中，以KV存储，一般，当并发量大时，且读很多时，采用Redis降低读压力，Redis一般存放热点数据

# Redis缓存

#  1. 底层数据结构

## 1.1. 压缩列表ziplist

- 使用场景：含有少数的键，且键是“短整型”、“短字符串”
- 优点：节省内存，实现简单，是连续内存块的顺序存储（有点像变长数组，它通过长度划分每个节点）
- 每个 压缩列表节点构成：前一个节点的长度pre_len 当前节点的长度、类型 当前节点的数据内容
- 连锁更新：当插入和删除元素时，可能会导致连锁更新。 ① （全small）原ziplist节点都是长度小于256：当在idx插入大于256的节点时，idx+1后面的节点e1的成员pre_len无法保存前一个节点的长度，因此，要重分配内存。这样e1内存就扩增了，因为是顺序存储，所以e2、e3后面的元素都要向后移动（更新） ② （big1、small、big2）：当删除small时，将会引起big2后面的节点连锁更新
- 使用场景：列表键、哈希键

## 1.2. 跳跃表

- 结构：是一个多层次的链表，每层节点的next跨度大小都不同，从上到下依次减小
- 时间复杂度：最好O（lgN），最差O（N） 性能可以和AVL树媲美，且实现简单
- 使用场景：zset有序集合键

## 1.3. 哈希表

- rehash（重新散列）：哈希键数量增多/减少，会造成rehash，保证哈希表负载因子维持在一个合理的范围。 分配新的哈希内存空间hash[1] 将原哈希hash[0]，通过rehash（重新计算哈希值），散列/迁移到新哈希hash[1]中 rehash过程不是一次执行的，而是分批次、渐进式执行的。

#  2. Redis五种数据结构

- 字符串键string | 字符串类型的value最大能容纳512M 
- 列表键         | ziplist、linklist               
- 哈希键         | ziplist、hash-table            
- 集合           | intset、hash-table
- 有序集合键     | ziplist、跳跃表                 
- 位图键         | bitmap                          

#  3. 删除机制

- 惰性删除： 只有访问时，采取查看该元素是否过期，过期才真正的删除。 
  - 优点：不需要频繁的删除，消耗CPU资源少 
  - 缺点：占用内存

- 定时删除：开启定时器，定时器到时间时，删除过期数据 
  - 优点：不占用内存
  - 缺点：消耗CPU资源少多

# 4. 持久化RDB/AOF

面试问法：Redis持久化机制介绍，各自优缺点。

- 先来介绍下，Redis是内存数据库，数据保存在内存中，但是内存数据容易丢失，对此，Redis提供了持久化机制：RDB（Redis DataBase）\AOF（Append only file）

## 4.1. RDB

在指定时间间隔内，将内存中的数据和操作，通过【快照】的方式保存到RDB文件，可以配置在N秒内进行一次快照。

- RDB三种触发机制

  - SAVE： save会阻塞Redis服务器进程，Redis不能处理客户端的其他命令请求，直到RDB文件创建完毕为止
  - 手动触发：bgsave会创建一个子进程，更新RDB文件，父进程可以继续处理请求 
  - 自动触发：通过Redis配置文件来完成
    - save m n：在m秒内数据集存在n次修改时，自动触发bgsave。
    - stop-writes-on-bgsave-error：默认为yes，当启用RDB且最后一次后台保存数据失败，Redis是否停止接收数据。（这回让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难发生了。若Redis重启了，就又可以重新开始接收数据了）
    - rdbcompression：默认是yes。对快照进行压缩存储
    - rdbchecksum：默认是yes。存储快照后，让Redis使用CRC64算法进行数据校验
- 优点
  - RDB文件紧凑、全量备份，非常适合于备份和灾难恢复
  - RDB恢复速度比AOF快（AOF要进行重放）
- 缺点
  - 不安全，会丢失时间间隔内的数据
  - 全量备份，耗用时间多
  -  每次保存RDB文件时，都需要fork一个子进程来持久化，性能开销较大

## 4.2. AOF

Redis将每次更新写操作命令，都以追加方式写入AOF文件。重启时，只需要从头到尾执行一次AOF中的指令，可以恢复数据

- rewrite

  为了防止AOF文件过大，采用了rewrite机制。（将对同一个key的操作，合并成一个语句，写入AOF文件）

- AOF三种触发机制
  - always：每次更新，都写一次AOF
  - everysec：每秒，写一次AOF （在1s内宕机，可能会数据丢失）
  - no：永不同步更新AOF

- 优点
  - AOF可以更好的保护数据不丢失
    - 一般AOF更新时间设置为1s，通过一个后台线程执行一次fsync，最多丢失1s的数据

- 缺点

  - 相同数据集，AOF文件要远大于RDB文件，恢复速度要重放（慢于RDB）

  - 一直更新写操作，会使AOF文件激增，极端场景下，会对硬盘空间造成压力 

---

- 加载顺序
  - RDB与AOF同时开启，默认先加载AOF

---



# 5. 高可用

## 5.1. 简介

- 高可用：当一台服务器宕机停止服务后，对业务及用户毫无影响

- 主从方式：正常情况下，主机提供服务，并将数据同步到备份机器，当主机宕机后，备机立即开始服务 。一主多从方式，主从之间数据同步。master宕机后，通过选举投票方式选择出新的master，继续提供服务。

- 主从方式主要实现读写分离，提高并发性，通过协调器将请求分发到主从节点上。  主从切换技术：当master服务器宕机后，slave切换为master

##  5.2. 哨兵

- 原理：哨兵将会监控集群中所有的节点；一般为了防止单哨兵节点故障，将配置多个哨兵协同合作。

- 切换过程

  - 主观下线：哨兵A检测到主节点下线后，将不会立即切换主节点，而是认为它客观下线 

  - 询问：哨兵A会询问监听该主节点的其他哨兵，收集汇总信息，当有足够多的主观下限信息时，判断是否为客观下线 

  - 选取新领头哨兵：当有一个哨兵判断为客观下限后，将会选举出领头哨兵，由它进行切换主节点操作

- 缺点

  - 运维复杂
  - 哨兵选举期间，不能对外提供服务（因此如果Master宕机后，不支持并发）

##  5.3. 集群

一个集群通常有多个服务器节点组成。 最开始时，各个服务器节点是相互独立的；之后，将各个节点连接起来

### 5.3.1. 槽指派

- 整个数据库，被划分为N个槽，每个槽记录了一个元组（键值对）
- 当`所有的槽都被分配/指派给节点`处理后，Redis服务器才会进入上线状态，此时才可以接收和处理客户端发来的数据请求

将槽分配到集群中某个节点的算法，一般采用取模算法、[一致性哈希算法](https://blog.csdn.net/weixin_36750623/article/details/84993780)。

### 5.3.2. 在集群中执行命令

- 当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽。
- 如果键所在的槽正好就指派给当前节点，那么当前节点直接执行该命令
- 如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令

### 5.3.3. 重新分片

定义：将任意数量已经指派给某个节点的槽，改为指派给另一个节点，并且相关槽所属的键值对也会从源节点移动到目标节点。

- 重新分片可以在线进行，即：在重新分片过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求

### 5.3.4. 复制

上面已经知道，集群中某个节点维护了某个区域的槽

- 为了防止该节点挂掉，一般对该节点进行复制，形成主从复制结构。
- 从节点会复制主节点的槽，当某个主节点故障了，因为从节点已经复制了它的槽，所以该从节点将会升级为主节点，继续服务。（与哨兵相比，在此期间，不会停止服务）

### 5.3.5. 故障检测
- 故障检测：每个节点会定时向集群中其他节点发送ping，检测对方是否在线; 
- 集群中各个节点会互相发送消息交换集群中各个节点的状态信息;
- 当某个主节点x疑似下线的数过半时，将会被标记为已下线，之后，会广播给集群中所有节点，告诉它们节点x已经下线

### 5.3.6. 故障转移/raft选主算法

会从下线的主节点的从节点中选取一个，让它成为新的主节点

新节点将会广播一条pong消息，通知其他节点自己已经变成了主节点

新主节点将接管原来已经下线的主节点，继续提供服务

# 6. Redis扩展特性

## 6.1. 发布订阅模式

- 客户端订阅服务端的频道

- 当服务端向该频道中发送消息时，频道中所有的客户端都会收到该消息，执行相应的动作 

## 6.2. 事务

### 6.2.1. SQL/Redis事务对比

SQL和Redis的事务有本质的区别

- SQL事务原理
  - innodb引擎支持的事务，采用Redo log + Undo log来实现
- Redis事务原理
  - 使用`乐观锁`，只负责监听key有没有被改动。
    - 采用watch监听某个key
    - 在执行命令时，检查该被监视的key是否已经被修改
    - 如果该key时被改动，那么事务将会被打断

与SQL事务最大的区别，Redis不支持事务回滚，即使事务在执行过程中出错，也不会回滚，将会一直执行下去，直到事务结束。 因为，开发者认为，事务执行失败，很少会在实际生产环境中出现。

## 6.3. 索引

 Redis没有实现索引，如果需要索引，需要用户自己设置并实现之 






# 7. Redis使用场景

## 7.1. String字符串对象

场景：统计网页/贴吧/文章阅读/浏览次数

```python
Incr article:readcnt:1001  # 对文章1001的读次数+1
```



## 7.2. Hash之淘宝商城购物车

## 7.3. List之微博公众号消息流

订阅了某个公众号，当该公众号发文章后，会推送给你！ 特点：消息的发送是有一个时间线的 

```python
LPAUSH msg:{小明微信号ID} 10018    # 发消息
LPAUSH msg:{小明微信号ID} 10011    # 发消息  
LRANGE msg:{小明微信号ID} 0 -1     # 查看最新的消息流列表
```



## 7.5.Bit位之日活量

场景：统计2020/10/03，登录用户数。现在系统有千万级活跃用户，如何实现日活统计，为了增强用户粘性，要上线一个连续打卡发放积分的功能，怎么实现连续打卡用户统计？

```python
将20201003Login作为key，offset作为每个用户，value 0/1表示都否登录，即：

Data    1  0  0  0  1  1  0 
Offset  0  1  2  3  4  5  ... ... 

Setbit 20201003Login 0 1 
Setbit 20201003Login 4 5 

bitcount 20201003Login 0 -1  # 统计日活

将20201003Login, 20201004Login,..., 20201007Login相与，之后再统计1的总个数 # 统计连续几日登录量
```



## 7.6. Set之微信抽奖小程序、微博点赞列表、微博关注模型	

无序不重复，放相同的元素，将会被去重（每个人点击多次抽奖，将会被去重，只视为一次抽奖）

场景1：微信抽奖小程序 

```python
SADD activity:10086 {用户ID}   # 用户点击抽奖按钮后，将加入set
SMEMBERS activity:10086       # 查看参与抽奖的所有用户
SRANDMEMBER activity:10086 2 SPOP activity:10086 2  # 随机抽取count名中奖者
```

场景2：微博点赞

```python
SADD like:{消息ID} {用户ID}      # 点赞
SREM like:{消息ID} {用户ID}      # 取消点赞
SISMEMBER like:{消息ID} {用户ID} # 检查用户是否点过赞
SMEMBERS like:{消息ID} {用户ID}  # 获取点赞的用户列表
SCARD like:{消息ID}             # 获取点赞用户总数
```

场景3：微博关注模型

James --\> {A,B,C} Kobe--\>{A,C,D,R} 

James、Kobe是两个集合Set 

```python
SINTER James Kobe      # 取出James和Kobe共同关注的人（交集） 
SISMEMBER James Jordan # 判断James集合中是否有Jordan 
SDIFF James Kobe       # James可能认识的人
```

场景4：Set实现电商商品类型的筛选 

```python
SADD brand:huawei P30 
SADD brand:xiaomi 6X 
SADD os:android P30 6X
SADD cpu:brand:intel P30 6X 
SADD ram:8G P30 6X
SINTER os:android cpu:brand:intel ram:8G  # -->{P30, 6X}
```



## 7.7. ZSet有序集合之微博热点排行榜

```python
ZINCRBY hotNews:20190722 1   # 点击新闻 
ZREVRANGE hotNews:20190722 0 10 WITH SCORES  # 展示当日排行前十
```

---



# 8. [Redis 6.0 的那些事](https://www.cnblogs.com/madashu/p/12832766.html)

**Redis单线程？多线程？**

之前说Redis是单线程，指的是Redis的`处理客户端请求事件`的主线程是“单线程的”，其实还是有一些后台线程在做任务。

- 主线程
  - Redis在处理客户端请求时（获取命令、解析命令、执行、返回内容）等操作都是由一个顺序串行的主线程处理的，这就是所谓的“单线程”。
- 后台线程
  - 清理脏数据、无用连接释放、大key的删除

---

**为什么Redis单线程模型处理速度如此快？**

- IO多路复用
  - 服务器接收客户端发来的请求命令是单线程的，它采用了IO多路复用能够同时监听多个事件的到来，当事件到来后，会将就绪事件挂到激活队列中，然后依次执行

---

**为什么Redis要一直使用单线程？**

- 多线程难以维护性
  - 增加系统复杂度：单线程的惰性删除、Rehash等操作都可以无锁实现
  - 存在线程切换，加锁解锁带来的性能消耗
- 使用多个Redis服务器组成集群，也能在一定程度上解决性能上的压力

----

**为什么Redis要引入多线程呢？**

- 随着业务场景越来越复杂，数据量越来越大，需要更大的QPS
- 使用多个Redis服务器组成集群，需要对它们进行维护，维护代价大
- 多线程能够充分的利用多核

---

**Redis6.0默认开启多线程么？如何开启和设置线程数？**

默认多线程模式是关闭的

```python
# io-threads 4
```

官方建议

- 4核机器建议设置为2或3，8核建议设置为6.（线程数一定要小于机器核数）

- 还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了

----

**开启多线程后，是否会存在线程并发安全问题？**

![](https://github.com/gEricy/knownledge/blob/master/A_%E6%95%B0%E6%8D%AE%E5%BA%93_SQL_Redis/%E5%8E%9F%E7%90%86%E5%9B%BE/Redis6.0%E5%A4%9A%E7%BA%BF%E7%A8%8B.png)

从上面的实现机制可以看出，Redis的多线程部分只是用来处理网络数据的读写和协议解析，（执行命令仍然是主线程顺序执行）。所以，不需要去考虑控制 key、lua、事务，LPUSH/LPOP 等等的并发及线程安全问题。

---

**Redis6.0的多线程和Memcached多线程模型进行对比**

- 相同点
  - 都采用了 master线程、worker 线程的模型
- 不同点
  - Memcached 执行主逻辑也是在 worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解（即：主线程采用 libevent 监听 listen、accept 的读事件，事件响应后将连接信息的数据结构封装起来，选择合适的工作线程进行后续的数据操作）
  - Redis 把处理逻辑交还给 master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题

# 9. Redis面试总结

​            在网上无意间，看到一个很好的贴子，里面介绍了较多面试题，也梳理了我们对问题的误区： 

- [整理了2019年40道Redis高频面试题，答案详细解析](https://www.bilibili.com/read/cv4042105/)

- [redis原理总结(很全面)](https://blog.csdn.net/wuyangyang555/article/details/82152005)
- [Redis双写一致性、并发竞争、线程模型](https://www.imooc.com/article/297496)
