# 前言

​          写在最前，本文主要以知识框架为主，根据自己对知识掌握的情况，进行知识点的梳理（有的知识点实际上上篇幅很大，但是由于自己已经理解，就没有详细叙述）。

# Redis缓存

#  0. 缓存雪崩/穿透/击穿

## 0.1. 缓存雪崩

大量的Redis缓存在某一时刻失效（就像雪崩来了一样），导致大量请求全部打到数据库上，导致数据库压力过大挂掉。

解决方案：熔断、降级、限流。（即：“熔断”，一旦发现当前服务的请求失败率达到预设的值，就拒绝随后该服务的所有请求。当经过一段时间后，会放行该服务的一部分请求，再次统计它的请求失败率。如果此时请求失败率符合预设值，则完全打开限流开关；如果请求失败率仍然很高，那么继续拒绝该服务的所有请求，这就是所谓的“限流”。而向那些被拒绝的请求直接返回一个预设结果，被称为“降级”）

## 0.2. 缓存穿透

恶意的用户，频繁访问数据库中不存在的数据，导致Redis查不到该数据就去数据库中查，导致缓存被穿透！

解决方案：对查询内容的合法性校验；布隆过滤器[过滤掉数据库中不存在的key]

## 0.3. 缓存击穿

双11秒杀某个商品的时候，某个商品的缓存key突然失效，导致一瞬间大量查询该key的请求打到数据库上，导致数据库挂掉。

解决方案：分布式锁（先对该商品加上锁，使得其他请求不能进来，然后将key写入缓存中，其他后来的请求就能从缓存中找到该key）

#  1. 底层数据结构

## 1.1. 压缩列表ziplist

| 压缩列表使用场景：含有少数的键，且键是“短整型”、“短字符串”   |
| ------------------------------------------------------------ |
| **优点**：节省内存，实现简单，是连续内存块的顺序存储（有点像变长数组，它通过长度划分每个节点） |
| **每个 节点构成**：前一个节点的长度pre_len 当前节点的长度、类型 当前节点的数据内容 |
| **连锁更新**：当插入和删除元素时，可能会导致连锁更新。 ① （全small）原ziplist节点都是长度小于256：当在idx插入大于256的节点时，idx+1后面的节点e1的成员pre_len无法保存前一个节点的长度，因此，要重分配内存。这样e1内存就扩增了，因为是顺序存储，所以e2、e3后面的元素都要向后移动（更新） ② （big1、small、big2）：当删除small时，将会引起big2后面的节点连锁更新 |
| **使用场景**：列表键、哈希键                                 |

## 1.2. 跳跃表

| 时间 | 最好O（lgN），最差O（N） 性能可以和AVL树媲美，且实现简单          |
|------|-------------------------------------------------------------------|
|      | 是一个多层次的链表 每层节点的next跨度大小都不同，从上到下依次减小 |
| 场景 | 有序集合键                                                        |

## 1.3. 哈希表

| 渐进式 rehash 过程 | rehash（重新散列）：哈希键数量增多/减少，会造成rehash，保证哈希表负载因子维持在一个合理的范围。 分配新的哈希内存空间hash[1] 将原哈希hash[0]，通过rehash（重新计算哈希值），散列/迁移到新哈希hash[1]中 rehash过程不是一次执行的，而是分批次、渐进式执行的。 |
|--------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 场景               | 哈希键                                                                                                                                                                                                                                                     |

#  2. Redis五种数据结构

| 字符串键string | 字符串类型的value最大能容纳512M |
|----------------|---------------------------------|
| 列表键         | ziplist、linklist               |
| 哈希键         | ziplist、hash-table             |
| 有序集合键     | ziplist、跳跃表                 |
| 位图键         | bitmap                          |

#  3. 对象的内存回收机制/对象共享

| 就是采用了引用计数，维护对象的声明周期                         |
|----------------------------------------------------------------|
| ① 当引用计数减为零时，释放该对象                               |
| ② 当引用计数大于1时，说明此时该对象至少被别人持有2次，即：共享 |

#  4. 过期时间\\过期删除机制

| 过期时间      | 当一个元素过期时，将会被删除，即：该key-value变为无效                                                                                                                                             |
|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 过期删除 机制 | 惰性删除： 只有访问时，采取查看该元素是否过期，过期才真正的删除。 优点：不需要频繁的删除，消耗CPU资源少 缺点：占用内存 定时删除：开启定时器，定时器到时间时，删除过期数据 优点缺点和方案①完全相反 |

# 5. 持久化RDB/AOF

| 面试问法：Redis持久化机制介绍，各自优缺点。 |                                                                                                                                                                                                                                               |
|---------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                             |                                                                                                                                                                                                                                               |
| RDB                                         | 在指定时间间隔内，将内存中的数据和操作，通过【快照】的方式保存到RDB文件，可以配置在N秒内进行一次快照。                                                                                                                                        |
| 触发 条件                                   | 1.手动触发：save命令和bgsave命令都可以生成RDB文件 save会阻塞Redis服务器进程，直到RDB文件创建完毕为止 bgsave会创建一个子进程，更新RDB文件，父进程可以继续处理请求 2.自动触发：redis.conf配置文件save m n，表示当m秒内发生n次变化时，触发bgsave |
| 优点                                        | 加载数据快，直接读取RDB文件内容加载到内存                                                                                                                                                                                                     |
| 缺点                                        | 1.不安全，会丢失时间间隔内的数据；2.每次保存RDB文件时，都需要fork一个子进程来持久化，性能开销较大；3.加载RDB文件期间，会一直处于阻塞状态，直到载入工作完成位置                                                                                |
|                                             |                                                                                                                                                                                                                                               |
| AOF                                         | 将每次更新写操作，都写到AOF文件，重启时，只需要从头到尾执行一次AOF中的指令，可以恢复数据                                                                                                                                                      |
| 优点                                        | 比较安全，可以配置一次更新写，就写AOF文件                                                                                                                                                                                                     |
| 缺点                                        | 一直更新写操作，会使AOF文件激增，极端场景下，会对硬盘空间造成压力 Redis重启时，需要重新执行一个很大的AOF，时间太长                                                                                                                            |
| Rewrite                                     | 将对同一个key的操作，合并成一个语句，写入AOF文件                                                                                                                                                                                              |
| 恢复顺序                                    |                                                                                                                                                                                                                                               |
|                                             | 当有AOF时，将会先执行AOF，再执行RDB                                                                                                                                                                                                           |

# 6. 高可用

## 6.1. 高可用介绍

| 高可用：当一台服务器宕机停止服务后，对业务及用户毫无影响                                                                                                                         |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 主备方式：正常情况下，主机提供服务，并将数据同步到备份机器，当主机宕机后，备机立即开始服务                                                                                       |
| 主从方式：一主多从方式，主从之间数据同步。Master宕机后，通过选举投票方式选择出新的master，继续提供服务。主从方式主要实现读写分离，提高并发性，通过协调器将请求分发到主从节点上。 |
| 主从切换技术：当master服务器宕机后，slave切换为master                                                                                                                            |

##  6.2. 哨兵

| 原理     | 哨兵将会监控集群中所有的节点；一般为了防止单哨兵节点故障，将配置多个哨兵协同合作。                                                                                                                                                                                                                                                                  |
|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 切换过程 | （主观下线）哨兵A检测到主节点下线后，将不会立即切换主节点，而是认为它客观下线 （询问）哨兵A会询问监听该主节点的其他哨兵，收集汇总信息，当有足够多的主观下限信息时，判断是否为客观下线 （选取领头哨兵）当有一个哨兵判断为客观下限后，将会选举出领头哨兵，由它进行切换主节点操作（即：故障转移操作） 会选择一个“好”的主从节点作为新的主节点，进行切换 |
| 缺点     | 运维复杂；哨兵选举期间，不能对外提供服务（因此如果Master宕机后，不支持并发）                                                                                                                                                                                                                                                                        |

##  6.3. 集群

|   | 一个集群通常有多个服务器节点组成。 最开始时，各个服务器节点是相互独立的；之后，将各个节点连接起来 |
|---|---------------------------------------------------------------------------------------------------|
|   |                                                                                                   |

### 6.3.1. 槽指派

|   | 整个数据库，被划分为N个槽，每个槽记录了一个元组（键值对）                                                  |
|---|------------------------------------------------------------------------------------------------------------|
|   | 当所有的槽都被分配/指派给节点处理后，Redis服务器才会进入上线状态，此时才可以接收和处理客户端发来的数据请求 |

### 6.3.2. 复制和故障转移

| 集群中主节点/从节点和主从复制中的主节点/从节点不是一个概念                                 |                                                                                |
|--------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------|
| 主节点                                                                                     | 当前集群中已经存在的节点                                                       |
| 从节点                                                                                     | 当前集群中新加入的节点（新加入的节点将会从原来的主节点中选择一个，复制它的槽） |
|                                                                                            |                                                                                |
| 如果某个主节点故障了，因为从节点已经复制了它的槽，所以该从节点将会升级为主节点，继续服务。 |                                                                                |

# 7. 其他特性

## 7.1. 发布订阅模式

客户端订阅服务端的频道；当服务端向该频道中发送消息时，频道中所有的客户端都会收到该消息，执行相应的动作 

## 7.2. 事务

### 7.2.1. MySQL和Redis的事务的区别

| 结论：二者在事务上有本质的区别 |                                                                                                                                                                               |
|--------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Redis 事务 原理                | 使用乐观锁，只负责监听key有没有被改动。即： 采用watch监听某个key；在执行命令时，检查该被监视的key是否已经被修改；如果该key时被改动，那么事务将会被打断                        |
|                                | 与SQL事务最大的区别，Redis不支持事务回滚，即使事务在执行过程中出错，也不会回滚，将会一直执行下去，直到事务结束。 因为，开发者认为，事务执行失败，很少会在实际生产环境中出现。 |

## 7.3. 索引

 Redis没有实现索引，如果需要索引，需要用户自己设置并实现之 



#  8. Redis面试题汇总

## 8.1. 开发中如何使用缓存（伪代码）

先查询缓存，①如果命中，就返回；②不命中，就查询数据库 



## 8.2. 怎么保证数据库和缓存一致性问题 \*\*

https://blog.csdn.net/diweikang/article/details/94406186

## 8.3. Redis是单线程还是多线程? 为什么采用单线程，效率却如此之高?

| Redis是单线程还是多线程要从两个方面谈起 ①服务器接收客户端发来的请求命令是单线程的，它采用了IO多路复用，与libevent事件驱动库一样，它是一种反应堆模式Reactor，服务器单线程同时监听多个事件的到来，当事件到来后，会将就绪事件挂到激活队列中 |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ②对于每一个就绪队列中任务的处理是多线程的，这也是Reactor模式高性能的体现，Reactor会事先建立一个线程池，线程池中的线程是消费者，当有任务到来时，线程将会获取任务执行它                                                                    |

## 8.4. 为什么redis不能代替mysql进行数据存储

| MYSQL是关系型数据库，大部分数据是存储在磁盘上的，以二维表格存储            |
|----------------------------------------------------------------------------|
| Redis是非关系型数据库，存放在内存中，以KV存储                              |
| 一般，当并发量大时，且读很多时，采用Redis降低读压力，Redis一般存放热点数据 |

# 9. Redis实现秒杀系统设计方案

## Q1：秒杀的时候，不同地域的客户端到达服务器的时间不同，怎么保证公平性？	




# 10. Redis使用场景

## 10.1. String字符串对象

| 场景：统计网页/贴吧/文章阅读/浏览次数           |
| ----------------------------------------------- |
| Incr article:readcnt:1001  对文章1001的读次数+1 |

## 10.2. Hash之淘宝商城购物车

## 10.3. List之微博公众号消息流

订阅了某个公众号，当该公众号发文章后，会推送给你！ 特点：消息的发送是有一个时间线的 

发消息： LPAUSH msg:{小明微信号ID} 10018   

发消息：  LPAUSH msg:{小明微信号ID} 10011   

查看最新的消息流列表：  LRANGE msg:{小明微信号ID} 0 -1    

## 10.5.Bit位之日活量

场景：统计2020/10/03，登录用户数。现在系统有千万级活跃用户，如何实现日活统计，为了增强用户粘性，要上线一个连续打卡发放积分的功能，怎么实现连续打卡用户统计？

将20201003Login作为key，offset作为每个用户，value 0/1表示都否登录，即：

20201003Login 

Data  1  0  0  0  1  1  0 

Offset  0  1  2  3  4  5  ... ... 

Setbit 20201003Login 0 1 

Setbit 20201003Login 4 5 

统计日活: bitcount 20201003Login 0 -1 

统计连续几日登录量: 将20201003Login, 20201004Login,..., 20201007Login相与，之后再统计1的总个数

## 10.6. Set之微信抽奖小程序、微博点赞列表、微博关注模型	

| 无序不重复，放相同的元素，将会被去重（每个人点击多次抽奖，将会被去重，只视为一次抽奖） 场景1：微信抽奖小程序 用户点击抽奖按钮后，将加入set： SADD activity:10086 {用户ID} 查看参与抽奖的所有用户：SMEMBERS activity:10086  随机抽取count名中奖者：SRANDMEMBER activity:10086 2 SPOP activity:10086 2 |
| ------------------------------------------------------------ |
| 场景2：微博点赞 点赞：SADD like:{消息ID} {用户ID} 取消点赞：SREM like:{消息ID} {用户ID} 检查用户是否点过赞：SISMEMBER like:{消息ID} {用户ID} 获取点赞的用户列表：SMEMBERS like:{消息ID} {用户ID} 获取点赞用户总数：SCARD like:{消息ID} |
| 场景3：微博关注模型 James --\> {A,B,C} Kobe--\>{A,C,D,R} James、Kobe是两个集合Set SINTER James Kobe  取出James和Kobe共同关注的人（交集） SISMEMBER James Jordan 判断James集合中是否有Jordan SDIFF James Kobe James可能认识的人 |
| 场景4：Set实现电商商品类型的筛选 SADD brand:huawei P30 SADD brand:xiaomi 6X SADD os:android P30 6X SADD cpu:brand:intel P30 6X SADD ram:8G P30 6X SINTER os:android cpu:brand:intel ram:8G --\>{P30, 6X} |

## 10.7. ZSet有序集合之微博热点排行榜

（1）点击新闻 ZINCRBY hotNews:20190722 1 双宋离婚 展示当日排行前十  ZREVRANGE hotNews:20190722 0 10 WITH SCORES 

（2）七日搜索榜单计算 ZUNIONSTORE hotNews:20190716-20190722 7 hotNews:20190716  hotNews:20190717 hotNews:20190718 ... ... hotNews:20190722 

（3）展示七日排行前十 ZREVRANGE hotNews:20190722 0 10 WITHSCORES



# 11. Redis面试总结

​            在网上无意间，看到一个很好的贴子，里面介绍了较多面试题，也梳理了我们对问题的误区： https://www.bilibili.com/read/cv4042105/ 


