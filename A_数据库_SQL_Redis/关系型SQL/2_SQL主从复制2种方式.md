### 2PC在SQL主从复制的应用

主从复制：2PC+redo log+binlog

1. prepare阶段： 引擎将数据，先写redo log
2. commit阶段： 再由执行器写binlog，最后执行器调用引擎的事务提交，把之前写完的redo log改成commit阶段，此时，一次事务更新操作完成


---





:sweat_smile: [主从复制的2种方式](https://blog.csdn.net/keil_wang/article/details/88669587)


**异步复制**：主服务器写完Binlog，不等同步给从服务器，就返回

**半同步复制**：主服务器写完Binlog，等待（同步）给任意一台从服务器，再返回

---

### 异步复制

<u>主库执行操作后，写入Binlog日志后，就返回客户端</u>，这一动作就结束了，并不会验证从库有没有收到，所以，`这样可能会造成主从数据不一致`。

> 在SQL中，有sync_binlog=n参数，表示每进行n次事务提交，SQL就将Binlog刷新到磁盘。如果该值设为1，就算数据库宕机了，最多只损失一次失误提交。

> 但是sync_binlog=1有以下缺点：①每次事务提交都要刷盘，影响数据库性能 ②SQL只能按照顺序来处理这些请求

异步复制的缺陷：主库提交事务写入Binlog后，当从库没有从主库得到Binlog时，由于主库宕机或磁盘损坏可能导致该事务的Binlog丢失了，那么从库就不会得到这个事务，也就造成了主从数据的不一致。

### 半同步复制

说明：MySQL5.5之后引入了半同步复制，解决异步复制的主从数据不一致的问题

当主库每次提交一个事务后，不会立即返回，而是：<u>等待其中一个从库接收到Binlog并成功写入RelayLog</u>，才返回客户端。

==> 这样，保证了一个事务至少有2份日志（一份保存在主库的Binlog，另一份保存在其中的一个从库的Relay-Log中，从而保证了数据的安全性和一致性）。

> 在半同步复制时，如果主库的一个事务提交成功了，在推送到从库的过程当中，
>
> 【Q1】从库宕机了或网络故障，导致从库并没有接收到这个事务的Binlog 
>
>       ==> 此时主库会等待一段时间（这个时间由rpl_semi_sync_master_timeout的毫秒数决定），
>
> 【Q2】如果这个时间过后还无法推送到从库
>
>       ==> 那MySQL会自动**从半同步复制切换为异步复制**；当从库恢复正常连接到主库后，主库**又会自动切换回半同步复制**

---

半同步复制的 **“半”** 体现在：

1. 虽然主从库的Binlog是同步的，但主库不会等待从库执行完Relay-log重放后才返回
2. 而是确认从库接收到Binlog，达到主从Binlog同步的目的后就返回了

所以从库的数据重放对于主库来说还是有延时的，这个延时就是从库执行Relay-log的时间，<u>所以只能称为半同步</u>。

